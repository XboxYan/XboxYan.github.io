<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>javascript 键盘访问半自动化解决方案 | XboxYan</title>
<link rel="shortcut icon" href="https://xboxyan.codelabo.cn/favicon.ico?v=1558506228503">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://xboxyan.codelabo.cn/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xboxyan.codelabo.cn">
  <img class="avatar" src="https://xboxyan.codelabo.cn/images/avatar.png?v=1558506228503" alt="">
  </a>
  <h1 class="site-title">
    XboxYan
  </h1>
  <p class="site-description">
    世界美好 你也是。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/XboxYan" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

      
        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              javascript 键盘访问半自动化解决方案
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-04-16 ·
              </time>
              
                <a href="https://xboxyan.codelabo.cn/tag/javascript" class="post-tags">
                  # javascript
                </a>
              
                <a href="https://xboxyan.codelabo.cn/tag/keyborad" class="post-tags">
                  # keyborad
                </a>
              
            </div>
            
              <div class="post-feature-image" style="background-image: url('https://xboxyan.codelabo.cn/post-images/javascript-auto-keyboard.jpg')">
              </div>
            
            <div class="post-content">
              <h2 id="概要">概要</h2>
<p>这是一个半自动化的键盘访问解决方案，主要适用于需要完全键盘操作场景，比如大屏展示，电视，游戏菜单等，大大简化按键操作的逻辑。</p>
<p>焦点使用虚拟焦点，也就是通过添加<code>.focus</code>等class实现，而不是原生自带的<code>:focus</code>，更利于定制化需求。</p>
<p>基于<code>HTML</code>页面。</p>
<blockquote>
<p>比较冷门，键盘交互方向，不感兴趣的可以跳过。</p>
</blockquote>
<p><a href="https://github.com/XboxYan/auto-keyboard">项目地址</a></p>
 <!-- more -->
<h2 id="特点">特点</h2>
<p>模块化编程方式</p>
<p>统一的按键处理</p>
<p>统一的滚动动画</p>
<p><a href="https://web.codelabo.cn/auto-keyboard/">马上体验</a></p>
<h2 id="快速入门">快速入门</h2>
<p>由于实际场景复杂多样，过于全反而会让业务代码更繁杂，不可维护。</p>
<p>该功能插件仅针对于局部实现自动化操作，整体页面布局仍需开发者手动协调。</p>
<p>具体是指开发者需要手动讲页面分为几块逻辑区域，比如下方的键盘区和搜索列表区。</p>
<p>然后对每块区域分别调用<code>new View()</code>，每一块区域的逻辑互不干扰，可独立开发。</p>
<pre><code class="language-html">&lt;link href=&quot;./css/view.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;div class=&quot;search_keyborad&quot; id=&quot;search&quot;&gt;
    &lt;a data-key=&quot;A&quot;&gt;A&lt;/a&gt;
    &lt;a data-key=&quot;B&quot;&gt;B&lt;/a&gt;
    &lt;a data-key=&quot;B&quot;&gt;C&lt;/a&gt;
    ...
&lt;/div&gt;
&lt;ul class=&quot;search_list&quot; id=&quot;list&quot;&gt;
    &lt;li class=&quot;search_item&quot;&gt;
        &lt;img src=&quot;&quot; &gt;
        &lt;h3&gt;11人类DNA密码破译&lt;/h3&gt;
    &lt;/li&gt;
    &lt;li class=&quot;search_item&quot;&gt;
        &lt;img src=&quot;&quot; &gt;
        &lt;h3&gt;22人类DNA密码破译&lt;/h3&gt;
    &lt;/li&gt;
    ...
&lt;/ul&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./js/smoothscroll.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./js/view.js&quot;&gt;&lt;/script&gt;
</code></pre>
<pre><code class="language-js">var S = $('search');	
var L = $('list');
var V = new View(S);
var Vl = new View(L);
V.init(S.getElementsByTagName('a'));
Vl.init(L.getElementsByTagName('li'));
V.onfocus();
</code></pre>
<p>这样，每块区域的按键都已经自动适配了。</p>
<p>然后针对每块区域的关联适当写一些逻辑即可。</p>
<h2 id="概念">概念</h2>
<p><strong>区域</strong> 指一块包含可获焦同类型同功能一类元素的集合，通过 <code>new View(container)</code>创建。</p>
<p><strong>元素</strong> 指区域里面每一个可以获焦的节点。</p>
<h2 id="api">API</h2>
<p>通过<code>new View(#container)</code>适配的区域，可获焦元素可以是常见的<code>n*m</code>分布，也可以是绝对定位的任意布局。</p>
<p>通过<code>V.init(children)</code>来初始化可获焦子元素，传入<code>nodeList</code>即可，与页面层级无关。</p>
<h3 id="new-viewcontainer">new View(container)</h3>
<p>核心方法。创建一个区域，传入参数为页面的一个容器。</p>
<pre><code class="language-js">var con = document.getElemetById('con');
var V = new View(con);
</code></pre>
<p>如果不传<code>container</code>，可创建一个虚拟的区域，你可以进入该区域进行其他操作，比如悬浮窗，视频播放等等。</p>
<p>该方法通常只需加载一次。</p>
<h3 id="vinitnodelist">V.init(nodeList)</h3>
<p>初始化，传入参数为需要获焦的子元素，通常使用<code>getElementsByTagName</code>来一次性传入多个。</p>
<p>也可以通过数组形式传入特定的子元素，如下。</p>
<pre><code class="language-js">var child = [ nodeA,nodeB,nodeC ];
V.init(child)
</code></pre>
<p>目的是能够完全控制子元素，因为有些情况下子元素可能不在同一层级。比如下方的<code>a</code>元素</p>
<pre><code class="language-html">&lt;div id=&quot;con&quot;&gt;
    &lt;a&gt;&lt;/a&gt;
    &lt;div&gt;
        &lt;span&gt;&lt;/span&gt;
        &lt;a&gt;&lt;/a&gt;
        &lt;a&gt;&lt;/a&gt;
    &lt;/div&gt;
    &lt;a&gt;&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<p>该方法需要等待页面加载完全后使用（需要获取元素的位置关系），也就是说当动态加载网络数据时，需等待只元素加入容器之后调用</p>
<pre><code class="language-js">V.init(S.getElementsByTagName('a'));

//动态数据
ajax({
    url:'XXX',
    sunccess:function(data){
        var html = '';
        for(var i=0;i&lt;data.length;i++){
            html+='&lt;a&gt;'+data[i]+'&lt;/a&gt;';
        }
        S.innerHTML = html;
        V.init(S.getElementsByTagName('a'));
    }
})
</code></pre>
<p>可以传空。此时表示该区域里面没有可获焦元素，常见场景为新闻类，此时该区域可以自动实现上下浏览的功能。</p>
<p>该方法通常只需加载一次。</p>
<h3 id="vinsertafternodelist">V.insertAfter(nodeList)</h3>
<p>向后追加子元素。常见场景为上拉加载，追加下一页等功能。</p>
<pre><code class="language-js">ajax({
    url:'XXX',
    sunccess:function(data){
        var div = document.createElement(&quot;div&quot;);
        var html = '';
        for(var i=0;i&lt;data.length;i++){
            html+='&lt;a&gt;'+data[i]+'&lt;/a&gt;';
        }
        div.innerHTML = html;
        M.appendChild(div);
        V.insertAfter(M.getElementsByTagName('a'));
    }
})
</code></pre>
<p>注意：追加元素时采用<code>M.appendChild(node)</code>方式，不要采用<code>M.inderHTML+=html</code>，因为</p>
<pre><code class="language-js">M.inderHTML += html;

//等效于

M.inderHTML = M.inderHTML + html;
</code></pre>
<p>会清空原有元素的状态。</p>
<h3 id="vinsertbeforenodelist">V.insertBefore(nodeList)</h3>
<p>与<code>insertAfter</code>相反，向前追加子元素。</p>
<h3 id="vonfocus">V.onfocus()</h3>
<p>主动聚焦，当有多个区域时，可选择控制。(区域)</p>
<pre><code class="language-js">var V = new View(S);
V.onfocus();
</code></pre>
<p>一个页面只有一个区域可以获焦，当一个区域获焦时，上一个区域会自动失去焦点。</p>
<blockquote>
<p>获焦的区域，容器会增加<code>focus</code>样式，通常在由子元素情况下，不会给容器增加额外样式，在没有子元素情况下，比如新闻浏览时，可以给容器加一个<code>focus</code>样式，以表示该区域正在获焦。</p>
</blockquote>
<p><strong>默认焦点</strong></p>
<p><code>autofocus</code>指定默认焦点，默认为该区域左上角的元素（有可能不是第<code>0</code>个，如绝对定位的情况）</p>
<p>给元素指定<code>autofocus=true</code>可以在初始化自动聚焦到该焦点。(DOM)</p>
<pre><code class="language-html">&lt;div&gt;
    &lt;a&gt;&lt;/a&gt;
    &lt;a autofocus=&quot;true&quot;&gt;&lt;/a&gt;
    &lt;a&gt;&lt;/a&gt;
    &lt;a&gt;&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<h3 id="vfocusbyidid">V.focusById(id)</h3>
<p>根据元素<code>id</code>聚焦，如果页面可滚动，则会自动定位到该元素。(元素)</p>
<h3 id="vfocusbyindexindex">V.focusByIndex(index)</h3>
<p>根据元素<code>index</code>聚焦，如果页面可滚动，则会自动定位到该元素。(元素)</p>
<p>这里的<code>index</code>指的是元素在文档中相对于其他子元素的顺序。</p>
<pre><code class="language-html">&lt;div&gt;
    &lt;a&gt;&lt;/a&gt; &lt;!--0--&gt;
    &lt;div&gt;
        &lt;span&gt;&lt;/span&gt;
        &lt;a&gt;&lt;/a&gt;  &lt;!--1--&gt;
        &lt;a&gt;&lt;/a&gt;  &lt;!--2--&gt;
    &lt;/div&gt;
    &lt;a&gt;&lt;/a&gt;  &lt;!--3--&gt;
&lt;/div&gt;
</code></pre>
<h3 id="vfindbydirdir">V.findByDir(dir)</h3>
<p>根据方位查找元素，返回元素<code>index</code>，找不到会返回<code>null</code>。</p>
<p><code>dir</code>是一个表示方位的数组，可依次传入<code>left</code>、<code>right</code>、<code>up</code>、<code>down</code></p>
<pre><code class="language-js">V.findByDir['right','down','down'] //表示当前元素的右边的下边的下边，可累计
</code></pre>
<p>通常用于边界提前判断，预加载。</p>
<p>例如，当下方还有两个元素（需要按两次“下”）的时候提前加载下一页。</p>
<pre><code class="language-js">if(!this.findByDir['down','down']){
    //...
    this.down();
    //...
}
</code></pre>
<h3 id="vsortbyarr">V.sortby(arr)</h3>
<p>自定义按键移动规则。</p>
<p>通常情况下会自动计算元素的上下左右关系，这是一个通用的计算方法，有些情况可能不尽人意，你可以通过该方法重新定义规则。</p>
<p>需要在<code>V.init(nodeList)</code>之后调用。</p>
<pre><code class="language-js">var rules = [
    [1,1,3,null],//第0个元素的位置关系
    [null,2,3,0],
    [1,null,3,1],
    [1,2,null,0],
]
V.sortby(rules);
</code></pre>
<p>这个数组每一项表示每一个元素的位置关系，按照文档中的顺序（从0开始），比如第<code>0</code>个<code>[1,1,3,null]</code>，表示</p>
<table>
<thead>
<tr>
<th>方向</th>
<th>序列</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>上</td>
<td><code>1</code></td>
<td>第1个元素</td>
</tr>
<tr>
<td>右</td>
<td><code>1</code></td>
<td>第1个元素</td>
</tr>
<tr>
<td>下</td>
<td><code>3</code></td>
<td>第3个元素</td>
</tr>
<tr>
<td>左</td>
<td><code>null</code></td>
<td>没有元素</td>
</tr>
</tbody>
</table>
<blockquote>
<p>只有极少部分情况下（元素有重叠交叉情况，或者需要人为干预）会用到该功能</p>
</blockquote>
<h3 id="回调">回调</h3>
<p>这一部分是对按键的回调</p>
<h4 id="vok">V.ok</h4>
<p>回车、确定。</p>
<p>当按下确定时，会给当前获焦元素添加<code>pressIn</code>类，抬起时移除，可自定义按下效果。</p>
<p>可以通过<code>V.isCurrent</code>来区分当前状态是否在点击同一个元素，优化体验。</p>
<pre><code class="language-js">V.ok = function(item){
    if(this.isCurrent){
        console.log('重复点击了该元素');
    }else{
        console.log(item)//当前获焦元素的dom节点
    }
}
</code></pre>
<p>鼠标点击会触发该事件。</p>
<h4 id="vleft-vright-vup-vdown">V.left、V.right、V.up、V.down</h4>
<p>向左/右/上/下（处于边界时）。当获焦元素处于区域边界时触发。一般用于跨越区域。</p>
<blockquote>
<p>当处于边界时，如果没有指定触发回调，比如<code>V.left</code>，会给当前获焦元素添加<code>shake</code>类，这是一个抖动动画，300ms自动移除。（位于css/view.css）</p>
</blockquote>
<pre><code class="language-js">V.left = function(){
    Vl.onfocus();//此时V会自动失去焦点，Vl会主动获焦
}
</code></pre>
<h4 id="vback">V.back</h4>
<p>返回。当按返回键时触发。</p>
<h4 id="vmove">V.move</h4>
<p>移动时触发，回调参数为移动之前的元素，和移动之后的元素。</p>
<pre><code class="language-js">V.move = function (prev, current) {
    //prev移动之前
    //current移动之前后
}
</code></pre>
<p>鼠标点击会触发该事件。</p>
<h3 id="属性">属性</h3>
<h4 id="vsavecurrent">V.saveCurrent</h4>
<p>是否保留当前状态，类名为<code>current</code>。一般用作<code>tab</code>切换时跟随。默认为<code>false</code>。</p>
<h4 id="vsavecurrentdelay">V.saveCurrentDelay</h4>
<p>是否保留当前状态，类名为<code>current</code>。一般用作<code>tab</code>切换时跟随，但是需要点击ok触发。默认为<code>false</code>。</p>
<blockquote>
<p>当重新回到该区域时，会自动定位到<code>current</code>位置。</p>
</blockquote>
<h3 id="vscrollanimate">V.scrollAnimate</h3>
<p>是否强制开启启动滚动动画（如果不支持会启用插件滚动）。默认为<code>true</code>。</p>
<p>页面滚动是通过修改<code>scrollTop</code>和<code>scrollLeft</code>完成，如果你需要一个区域滚动，必须指明宽度或者高度，同时设置<code>overflow:hidden|auto</code>才能生效。</p>
<p>如果需要动画，可以增加属性<code>scroll-behavior: smooth</code>（可能有兼容性问题，不影响功能）</p>
<p>或者引入<code>smoothscroll.min.js</code>，设置<code>V.scrollAnimate = true</code>。</p>
<h3 id="指令">指令</h3>
<p>类似于控制台，通过一些方法来模拟该区域实际的按键操作。</p>
<h4 id="vonkeyaction">V.onkey(action)</h4>
<p><em>action</em>可选值<code>up</code>、<code>right</code>、<code>down</code>、<code>left</code>、<code>ok</code>、<code>back</code>，可主动调用该区域的按键操作。</p>
<p>与真实的按键操作响应无异，包括该按键对应的回调事件。</p>
<pre><code class="language-js">V.right = function () {
    Vnav.onfocus();
    Vnav.onkey('right');
    Vnav.onkey('down');
}
</code></pre>
<h3 id="全局指令">全局指令</h3>
<p><code>moveLeft</code>、<code>moveUp</code>、<code>moveRight</code>、<code>moveDown</code>、<code>doConfirm</code>、<code>keyBack</code></p>
<p>该方法可以直接暴露给外部使用，从全局控制页面的焦点移动。</p>
<p>通常适用于接管安卓的按键响应事件。</p>
<pre><code class="language-js">//console
moveLeft();
moveUp();
//...
</code></pre>
<h3 id="鼠标操作">鼠标操作</h3>
<p>现支持鼠标快速操作，可以同键盘无缝使用。</p>
<p>点击鼠标左键可以触发元素的<code>ok</code>事件</p>
<p>点击区域可以对区域进行聚焦。</p>
<p>详细规则可以体验下面demo，与常规页面体验无异。</p>
<blockquote>
<p>注意：如果需要使用鼠标滚轮滚动，那么需要设置容器<code>overflow:auto</code>,而不能是<code>overflow:hidden</code></p>
</blockquote>
<h2 id="案例">案例</h2>
<p><a href="https://web.codelabo.cn/auto-keyboard/">https://web.codelabo.cn/auto-keyboard/</a></p>
<p><strong>请使用键盘方向键上下左右体验，可以配合鼠标操作</strong></p>
<blockquote>
<p>可以查看源码，代码量很小，却有意想不到的效果。</p>
</blockquote>
<h2 id="结语">结语</h2>
<p>目前市面上并没有什么对键盘操作封装的库，键盘什么的这个方向确实比较窄，或者说比较冷门，希望能够帮助特定的人群吧。</p>
<p>有这方面兴趣的欢迎交流，一起讨论。</p>

            </div>
          </article>
        </div>
    
        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xboxyan.codelabo.cn/post/hello-gridea">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>  
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '76f6db0817582f8fcf7e',
    clientSecret: '0bff99f569efc8e061740c67585348de78e81e58',
    repo: 'XboxYan.github.io',
    owner: 'XboxYan',
    admin: ['XboxYan'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        
    
        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
